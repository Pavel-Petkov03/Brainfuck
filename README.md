
# Brainfuck Interpreter Project

This project implements an interpreter for the esoteric programming language Brainfuck. The goal is to read and execute Brainfuck programs, providing the ability to chain and combine multiple programs together.

## Introduction

Brainfuck is a minimalistic programming language that operates on an array of memory cells, each initially set to zero. The language has only eight commands, which manipulate the data and control the flow of the program. The commands in Brainfuck are:

- `>`: Move the data pointer to the right.
- `<`: Move the data pointer to the left.
- `+`: Increment the byte at the data pointer.
- `-`: Decrement the byte at the data pointer.
- `.`: Output the byte at the data pointer as a character.
- `,`: Input a character and store it at the data pointer.
- `[`: Jump forward to the corresponding `]` if the byte at the data pointer is zero.
- `]`: Jump back to the corresponding `[` if the byte at the data pointer is non-zero.

The interpreter can process Brainfuck code from a file and handle input/output streams, with the ability to combine, parallelize, and alternate multiple Brainfuck programs.

## Main Functionality

The core functionality of this project is implemented in the following functions:

### 1. `brainfuck` Function

#### Input:
- `filename` (string): The path to a file that contains the Brainfuck code.
- `input-list` (List of characters): A list of characters in Scheme format representing the input stream to be used by the Brainfuck program.

#### Example Usage:
```scheme
(brainfuck "testFiles/hello.txt" '())
```

In this example:
- `"testFiles/hello.txt"` is the path to the Brainfuck code file.

#### Output:
The function processes the Brainfuck code and returns the output generated by the program. For example, if the Brainfuck code in the file is designed to output `"Hello World!"`, the result could look like:

```
'(#\H #\e #\l #\l #\o #\, #\space #\W #\o #\r #\l #\d #\!)
```

### 2. `concatenate-programs` Function

#### Input:
- `filename1` (string): The path to the first Brainfuck code file.
- `filename2` (string): The path to the second Brainfuck code file.
- `input-list` (List of characters): A list of characters in Scheme format representing the input stream for the first Brainfuck program.

#### Example Usage:
```scheme
(concatenate-programs "testFiles/identity.txt" "testFiles/addNumbers.txt" '(#\1 #\3))
```

In this example:
- `"testFiles/indentity.txt"` takes two numbers from input and returns them.
- `"testFiles/addNumbers.txt"` adds two numbers given from input.
- `(#\1 #\3)` is the input list, which is an empty list in this case, meaning no additional input will be provided.

#### Description:
This function executes the Brainfuck program from the first file using the provided `input-list`. The output generated from the execution of the first program is then used as the input for the second Brainfuck program, which is executed in turn. The final output from the second program is returned.

#### Output:

```
(#\4)
```

### 3. `parallel-programs` Function

#### Input:
- `filename1` (string): The path to the first Brainfuck code file.
- `filename2` (string): The path to the second Brainfuck code file.
- `input-list` (List of characters): A list of characters in Scheme format representing the input stream for both Brainfuck programs.

#### Description:
This function executes both Brainfuck programs in parallel, meaning both programs will receive the same input list at the same time. The output from both programs will be combined into a single result.

#### Example Usage:
```scheme
(parallel-programs "testFiles/hello.txt" "testFiles/secondProgram.bf" '())
```

#### Output:
The function will return the combined output from both programs.

```
'(#\H #\e #\l #\l #\o #\, #\space #\W #\o #\r #\l #\d #\! #\H #\e #\l #\l #\o #\, #\space #\W #\o #\r #\l #\d #\!)
```
The reason in this case the output is not distributed between both the programs is that if the programs are too fast
The first will be executed before the second
### 4. `alternate-programs` Function

#### Input:
- `filename1` (string): The path to the first Brainfuck code file.
- `filename2` (string): The path to the second Brainfuck code file.
- `input-list` (List of characters): A list of characters in Scheme format representing the input stream for both Brainfuck programs.

#### Description:
This function executes both Brainfuck programs alternately, meaning the programs will take turns reading from the input list. The output from both programs will be combined into a single result.

#### Example Usage:
```scheme
(alternating-programs "testFiles/addNumbers.txt" "testFiles/addNumbers.txt" '(#\1 #\2 #\3 #\4))
```

#### Output:
The function will alternate taking numbers from input which will make 1 , 3 input for the first program and 2, 4 for the second which results in

```
`(#\4 #\6)
```

### 5. `bynary-to-brainfuck` Function

#### Input:
- `filename` (string): path to encoded brainfuck file.
- `input-list` (List of characters): A list of characters in Scheme format representing the input stream for both Brainfuck programs.

#### Description:
### the filename must be bynary file with the following encoding  ###
- `000` is ">"
- `001` is "<"
- `010` is "+"
- `011` is "-"
- `100` is "."
- `101` is ","
- `110` is "["
- `111` is "]"




## Installation

To get started with the project, clone the repository to your local machine using the following command:

```
git clone https://github.com/Pavel-Petkov03/Brainfuck.git
```

### Dependencies

- Scheme (Racket or any compatible Scheme implementation)
- rebellion/concurrency/lock (used for multithreading)
```
raco pkg install rebellion/concurrency/lock
```

### Running the Code

To run the code, open the Scheme environment (e.g., Racket) and load the file containing the functions. After loading the file, you can call the functions as shown in the examples above.
